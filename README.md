# Informace o úloze #
Tato úloha je specificky na multithreading v jazyce C++. Jedná se o těžší verzi problému producent/konzument.
Zadání je, že náš program je určen pro svářecí společnost (CWeldingCompany) prodávající plechy (COrder) a máme být schopni obsluhovat několik zákazníků (CCustomer) najednou, získávat od nich poptávky (COrderList) na určitý typ materiálu(material_id), nacenit požadované plechy v nich pomocí ceníků (CPriceList) od dodavatelů (CProducer) a následně jim poptávky vracet. 
Plechy nelze řezat a lze je pouze skládat a svářet k sobě. Svářet navíc lze pouze plechy, jejichž svářené hrany jsou stejně dlouhé. Například: máme plechy ve formátu <šířka> x <výška>, k dispozici máme plechy 3x4, 3x6 a 4x9. Nejdříve lze svařit k sobě plechy 3x4 a 3x6 a vytvořit tak plech o velikosti 3x9, protože mají stejnou šířku. Tento plech lze pak svařit s plechem o velikosti 4x9 a vytvořit tak plech o velikosti 7x9, protože mají stejnou výšku.

Vlákna jsem rozdělil na obslužná a pracovní. Ke každému zákazníkovi jsem přidělil jedno obslužné vlákno. Obslužné vlákno si vyžádalo poptávku, zjistilo, zda informace o materiálu (a tedy i unifikovaný ceník bez duplicit) je zaznamenána v mém programu. Pokud není, tak paralelně obvolají všechny producenty a požádají je o jejich ceníky na daný materiál. Dodavatelé své ceníky pak posílají buď synchronně, nebo asynchronně, takže pak obslužné vlákna musí počkat, dokud nedostanou k danému materiálu ceníky od všech dodavatelů. Jakmile je dostanou, tak to obslužné vlákno ty ceníky zkompletuje do jednoho velkého ceníku bez duplicit (preferuje levnější verzi plechu) a následně naplní společný buffer jednotlivými žádanými plechy a informacemi o zákazníkovi, poptávce a počtu naceněných plechů. Přitom zároveň probouzí pracovní vlákna, která spí a čekají, než bude společný buffer neprádný.

Pracovní vlákno se probudí, vyzvedne si požadovaný plech, vypočítá jeho nejmenší možnou cenu na výrobu pomocí metody seqSolve, zvýší počet naceněných plechů a pokud jsou všechny plechy jedné poptávky naceněné, tak danou poptávku vrátí zpátky zákazníkovi.
SeqSolve používá dynamické programování, aby v kubickém čase efektivně nacenila zadaný plech. Nacenění probíhá tak, že se postupně skládají dostupné plechy z unifikovaného ceníku a ukládají se ty nejmenší ceny. Nakonec se vrací cena požadovaného plechu od zákazníka. Výhodou je, že každé pracovní vlákno má právě svůj plech ke zpracování, takže seqSolve není nutné zamykat a může tedy tato metoda běžet paralelně najednou souběžně s dalšími pracovními vlákny. 

Jakmile obslužné vlákno zjistí, že zákazník už nepošle další objednávky, tak se dekrementuje počet aktivních obslužných vláken a jakmile se tento počet rovná nule, tak poslední obslužné vlákno "zhasne". To znamená, že tolikrát, kolik je pracovních vláken, tak společný buffer zaplní "dummy" prvky. Každé pracovní vlákno si pak vyzvedne jeden dummy prvek, zjistí, že to je dummy ukončovací prvek a ta pracovní funkce skončí. Ve stop metodě se pak akorát k hlavnímu vláknu napojí všechny obslužná vlákna (která už nejsou aktivní) a pracovní vlákna (která už čistě také nejsou aktivní).

## Informace o repozitáři ##
Ve složce _progtest_ naleznete mou implementaci v souboru __solution.cpp__. Ke kompilaci se používá _Makefile_ a příkaz "make". Spuštění pak lze provést zavoláním "./test". Pro dodatečné testování lze zakomentovat main funkci v souboru _solution.cpp_ a odkomentovat _testing.o_ v Makefile. Tím se společně s ostatními závislými soubory zkompiluje i __testing.cpp__ soubor, kde si v main funkci lze navolit libovolný počet pracovních vláken, zákazníků a synchronních či asynchronních dodavatelů. Na závěr _dp_solver_solution.cpp_ obsahuje prvotní řešení kubického algoritmu na vyřešení minimální ceny za zkombinování nabízených plechů do toho požadovaného. 
